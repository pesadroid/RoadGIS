package xyz.geosure.roadgis.utils;

import com.vividsolutions.jts.geom.Point;
import com.vividsolutions.jts.math.Vector2D;


public class VectorUtils {

	

	// vector p1->p2
	public static Vector2D vector(Point p1, Point p2 ) 	{//Modified by Felix to change the type from PointF to Coodinate
		Vector2D vec = new Vector2D(p2.getX() - p1.getX(), p2.getY() - p1.getY());
		return vec;
	}
	public static double vectorDOT(Vector2D v1, Vector2D v2 ) {
		return v1.getX()*v2.getX()+v1.getY()*v2.getY() ;
	}
	// return vector angle in deg, 0deg at 3 oclock dir, + for CCW dir
	public static double vectorAngle(Point p1, Point p2 ) 
	{
		double angle ;
		Vector2D _vec  = new Vector2D(p2.getX() - p1.getX(), p2.getY() - p1.getY());
		angle = Math.atan2(-_vec.getY(), _vec.getX())*180.0/Math.PI ;    // degree
		return angle ; 
	}

	public static double distanceOf(Point p1 , Point p2 ) {
		double dist, dx, dy ;//Changed by Felix from float to double
		dx = p1.getX() - p2.getX();
		dy = p1.getY() - p2.getY();
		dist = new Double(Math.sqrt(dx*dx + dy*dy));//.floatValue();
		return dist;
	}


	public static double getCosTheta(Vector2D v1, Vector2D v2) {
		double cos_theta, dot, v1_len, v2_len;
		dot = v1.getX() * v2.getX() + v1.getY() * v2.getY();
		v1_len = Math.sqrt(v1.getX()*v1.getX() + v1.getY()*v1.getY());
		v2_len = Math.sqrt(v2.getX()*v2.getX() + v2.getY()*v2.getY());
		cos_theta = dot / (v1_len * v2_len);
		return new Double(cos_theta);//.floatValue();
	}
	

	public static double calcDist2Line(Point p, Point p0, Point p1){
		double dx, dy ;
		dx = p1.getX() - p0.getX() ;
		dy = p1.getY() - p0.getY() ;
		double dist = Math.abs((dx*p.getY()-dy*p.getX()+p0.getX()*p1.getY()-p1.getX()*p0.getY())/Math.sqrt(dx*dx+dy*dy)) ;
		return (new Double(dist));//.floatValue()) ;
	}
	

	// added 11/17/06 to process angle (deg) after generated by ATAN2
	// when vectors span over +/- PI boundary
	public static double processAngle(double angle) {
		double angle_ret=0 ;
		if (angle > 180) {
			angle_ret = angle - 360;
		} else if (angle < -180) {
			angle_ret = angle + 360 ;
		} else {
			angle_ret = angle ;
		}
		return angle_ret ;
	}
}
